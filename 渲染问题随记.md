### 浮点精度问题

**问题描述**：当物体离开世界圆心位置非常远的时候，浮点数的精度会出现问题，导致动画出现跳动，Zfighting画面闪烁等

> 动画问题是因为CPU端在计算骨骼Transform，如果父子关系深度过深，连续矩阵乘法，则会使这个误差变大。其实不仅仅是动画，其他只要用到transform的，有很深的父子关系的都会出这个问题，只是动画一般父子关系比较深，且每帧都在变化，对这个问题更加敏感。unity的transform貌似是用float存储的，如果用double存储和计算牺牲点性能应该能解决这个精度问题，不过传到gpu还得是float，没有深究过到底能不能解决这个问题。
> 
> Zfighting则是GPU端的depth浮点问题，一般通过翻转Z（unity默认支持）和Depth Offset来缓解的。GPU相比CPU为了低功耗和运算效率在浮点运算上设计得就更加精简，代价就是损失运算精度。并且depth本身存储一般是24位（被stencil占了8位），当然中间运算一般还是float。通过MVP的矩阵运算，在远离原点后M精度损失，Z值计算出现误差导致深度测试结果不确定。这里也要注意就是不要为了少传几个矩阵，把MVP分别传入，然后在shader里重新计算，这不仅多了矩阵乘法复杂度，还会使浮点误差放大。

**解决方法**：
如果只是Zfighting问题可以使用
```hlsl
o.clipPos = mul(GetViewToHClipMatrix(), mul(GetWorldToViewMatrix(), float4(TransformObjectToWorld(v.vertex.xyz), 1)));
```
这种把矩阵拆分出来计算ClipPos的方法
项目中实测离开圆心1500个单位的物体的描边与着色的Zfighting问题能够被解决
（解决原因未知，原理上和使用函数没有实际区别）

如果还有衍生的动画等等问题，则需要在设计阶段就考虑到这个问题
基本思路都一样，即：当超过一定范围，把整个大世界平移一下，使坐标参考系始终在相机周围。

静态合批因为是基于世界空间，所以发生平移的时候会出现问题，这时候通过Shader中VS统一平移，同时重设SubMesh的剔除Bounds，不然基于原位置剔除会出现问题


